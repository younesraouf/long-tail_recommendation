import random
import numpy as np
import pandas as pd
from typing import List, Tuple, Dict

class MORSOptimizer:
    """
    Multi-Objective Evolutionary Algorithm for Recommendation (MORS).
    
    This class implements the optimization phase where the algorithm looks for 
    the best trade-off between:
    1. Accuracy (maximizing predicted ratings)
    2. Novelty (maximizing long-tail item inclusion)
    
    Attributes:
        candidates (list): List of tuples (item_id, predicted_rating).
        item_stats (pd.DataFrame): DataFrame containing 'mu' (mean) and 'sigma' (variance).
        list_length (int): Length of the final recommendation list.
        pop_size (int): Size of the genetic population.
    """

    def __init__(self, candidates: List[Tuple[int, float]], item_stats: pd.DataFrame, 
                 list_length: int = 10, population_size: int = 50, mutation_rate: float = 0.3):
        """
        Initializes the Optimizer.

        Args:
            candidates: Pool of high-potential items generated by Phase 2 (CF).
            item_stats: Statistics (mean/var) from Phase 1 for novelty calculation.
            list_length: Number of items to recommend to the user.
            population_size: Number of solutions to evolve simultaneously.
            mutation_rate: Probability of mutation occurring.
        """
        self.candidates = candidates
        # Create a quick lookup dictionary for predictions: {item_id: rating}
        self.candidate_map = {item: score for item, score in candidates}
        self.item_stats = item_stats
        self.list_length = list_length
        self.pop_size = population_size
        self.mutation_rate = mutation_rate
        self.population = []

    def _calculate_novelty_score(self, item_id: int) -> float:
        """
        Calculates the novelty score for a single item.
        Based on Eq. (9) from Wang et al. (2016).
        
        Formula: m_i = 1 / (mu * (sigma + 1)^2)
        
        Args:
            item_id: The item to evaluate.
            
        Returns:
            float: Novelty score. Higher means more novel (less popular/stable).
        """
        if item_id not in self.item_stats.index:
            return 0.0
        
        stats = self.item_stats.loc[item_id]
        mu = stats['mu']
        sigma = stats['sigma']
        
        # Avoid division by zero
        if mu == 0: 
            return 1.0 
        
        return 1.0 / (mu * (sigma + 1.0)**2)

    def evaluate(self, individual: List[int]) -> Tuple[float, float]:
        """
        Evaluates a single solution (list of items).

        Args:
            individual: List of item IDs.

        Returns:
            tuple: (Accuracy Score, Novelty Score)
        """
        # Objective 1: Accuracy (Sum of predicted ratings)
        accuracy = sum([self.candidate_map.get(item, 0) for item in individual])

        # Objective 2: Novelty (Sum of novelty scores)
        novelty = sum([self._calculate_novelty_score(item) for item in individual])
        
        return accuracy, novelty

    def initialize_population(self):
        """Generates the initial population randomly from the candidate pool."""
        print(f"[INFO] Initializing population of size {self.pop_size}...")
        self.population = []
        candidate_ids = [c[0] for c in self.candidates]
        
        for _ in range(self.pop_size):
            # Randomly sample unique items to form a list
            if len(candidate_ids) >= self.list_length:
                ind = random.sample(candidate_ids, self.list_length)
                self.population.append(ind)
            else:
                # Fallback if pool is too small
                self.population.append(candidate_ids[:self.list_length])

    def crossover(self, parent1: List[int], parent2: List[int]) -> Tuple[List[int], List[int]]:
        """
        Performs Single-Point Crossover.
        
        Splits parents at a random point and swaps tails.
        Ensures children do not contain duplicate items.
        """
        point = random.randint(1, self.list_length - 1)
        
        child1_raw = parent1[:point] + parent2[point:]
        child2_raw = parent2[:point] + parent1[point:]
        
        child1 = self._fix_duplicates(child1_raw)
        child2 = self._fix_duplicates(child2_raw)
        
        return child1, child2

    def _fix_duplicates(self, individual: List[int]) -> List[int]:
        """
        Removes duplicates from a recommendation list and fills gaps with new items.
        """
        seen = set()
        clean_ind = []
        candidate_ids = [c[0] for c in self.candidates]
        
        # Keep unique items preserving order
        for item in individual:
            if item not in seen:
                clean_ind.append(item)
                seen.add(item)
        
        # Fill missing slots with random items from pool not currently in list
        while len(clean_ind) < self.list_length:
            new_item = random.choice(candidate_ids)
            if new_item not in seen:
                clean_ind.append(new_item)
                seen.add(new_item)
                
        return clean_ind

    def mutation(self, individual: List[int]) -> List[int]:
        """
        Performs mutation by swapping one item with a random item from the pool.
        """
        if random.random() < self.mutation_rate:
            idx = random.randint(0, self.list_length - 1)
            candidate_ids = [c[0] for c in self.candidates]
            
            new_gene = random.choice(candidate_ids)
            # Ensure we don't introduce a duplicate
            while new_gene in individual:
                new_gene = random.choice(candidate_ids)
            
            individual[idx] = new_gene
            
        return individual

    def run(self, generations: int = 50) -> List[Dict]:
        """
        Executes the evolutionary process.

        Args:
            generations (int): Number of generations to evolve.

        Returns:
            List[Dict]: A list of unique solutions with their scores.
        """
        self.initialize_population()
        
        for gen in range(generations):
            # 1. Evaluate current population
            scored_pop = [(ind, self.evaluate(ind)) for ind in self.population]
            
            # 2. Selection (Simplified elitism based on weighted sum for diversity)
            # We want to keep solutions that are good at Acc, Nov, or both.
            scored_pop.sort(key=lambda x: x[1][0] + x[1][1] * 10, reverse=True)
            
            # Keep top 50% as parents
            parents = [x[0] for x in scored_pop[:self.pop_size // 2]]
            
            next_generation = parents[:]
            
            # 3. Reproduction
            while len(next_generation) < self.pop_size:
                # Randomly select 2 parents
                p1 = random.choice(parents)
                p2 = random.choice(parents)
                
                c1, c2 = self.crossover(p1, p2)
                
                next_generation.append(self.mutation(c1))
                if len(next_generation) < self.pop_size:
                    next_generation.append(self.mutation(c2))
            
            self.population = next_generation
            
            if (gen + 1) % 10 == 0:
                best = self.evaluate(self.population[0])
                print(f"[Gen {gen+1}] Best Accuracy: {best[0]:.2f} | Best Novelty: {best[1]:.4f}")

        # Final Evaluation and Cleanup
        unique_solutions = {}
        for ind in self.population:
            # Sort tuple to use as dictionary key (sets are not hashable)
            key = tuple(sorted(ind))
            if key not in unique_solutions:
                acc, nov = self.evaluate(ind)
                unique_solutions[key] = {
                    'items': ind,
                    'accuracy': acc,
                    'novelty': nov
                }
        
        return list(unique_solutions.values())